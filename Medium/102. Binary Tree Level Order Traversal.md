# [102. Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal)

## Description

Given the `root` of a binary tree, return _the level order traversal of its nodes' values_. (i.e., from left to right, level by level).

**Example 1:**

![](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

**Input:** root = \[3,9,20,null,null,15,7\]  
**Output:** \[\[3\],\[9,20\],\[15,7\]\]

**Example 2:**

**Input:** root = \[1\]  
**Output:** \[\[1\]\]

**Example 3:**

**Input:** root = \[\]  
**Output:** \[\]

**Constraints:**

- The number of nodes in the tree is in the range `[0, 2000]`.
- `-1000 <= Node.val <= 1000`

## My Solution

**JavaScript**

```js
// Approach: Using a Queue, no extra data paired with the nodes
const levelOrder = (root) => {
  if (!root) return [];

  const result = [];

  // Level-Order Traversal is easiest with a queue rather than a stack / recursion
  const queue = [root];

  while (queue.length) {
    // Keep track of how many nodes are currently in the queue. This represents how
    // many nodes are part of the current level
    const levelLength = queue.length;
    const currentLevel = [];

    // For each node on the current level of the tree...
    for (let i = 0; i < levelLength; ++i) {
      // Pop the node and process it
      const current = queue.shift();
      currentLevel.push(current.val);

      // Add its left and right children to the end of the queue
      if (current.left) queue.push(current.left);
      if (current.right) queue.push(current.right);
    }

    // By this point all the nodes in the current level of the tree were popped and process
    // Only each of those nodes' children are in it. Push all the nodes we found on this level
    // to the result array
    result.push(currentLevel);
  }

  return result;
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(N)             |
