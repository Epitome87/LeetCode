# [3814. Maximum Capacity Within Budget](https://leetcode.com/problems/maximum-capacity-within-budget)

## Description

You are given two integer arrays `costs` and `capacity`, both of length `n`, where `costs[i]` represents the purchase cost of the `ith` machine and `capacity[i]` represents its performance capacity.

You are also given an integer `budget`.

You may select **at most two distinct** machines such that the **total cost** of the selected machines is **strictly less** than `budget`.

Return the **maximum** achievable total capacity of the selected machines.

**Example 1:**

**Input:** costs = \[4,8,5,3\], capacity = \[1,5,2,7\], budget = 8  
**Output:** 8  
**Explanation:**

- Choose two machines with `costs[0] = 4` and `costs[3] = 3`.
- The total cost is `4 + 3 = 7`, which is strictly less than `budget = 8`.
- The maximum total capacity is `capacity[0] + capacity[3] = 1 + 7 = 8`.

**Example 2:**

**Input:** costs = \[3,5,7,4\], capacity = \[2,4,3,6\], budget = 7  
**Output:** 6  
**Explanation:**

- Choose one machine with `costs[3] = 4`.
- The total cost is 4, which is strictly less than `budget = 7`.
- The maximum total capacity is `capacity[3] = 6`.

**Example 3:**

**Input:** costs = \[2,2,2\], capacity = \[3,5,4\], budget = 5  
**Output:** 9  
**Explanation:**

- Choose two machines with `costs[1] = 2` and `costs[2] = 2`.
- The total cost is `2 + 2 = 4`, which is strictly less than `budget = 5`.
- The maximum total capacity is `capacity[1] + capacity[2] = 5 + 4 = 9`.

**Constraints:**

- `1 <= n == costs.length == capacity.length <= 10^5`
- `1 <= costs[i], capacity[i] <= 10^5`
- `1 <= budget <= 2 * 10^5`

## My Solution

**JavaScript**

```js
const maxCapacity = (costs, capacity, budget) => {
  const machines = [];

  // Create array of machine objects with cost and capacity keys
  for (let i = 0; i < costs.length; ++i) {
    machines.push({ cost: costs[i], capacity: capacity[i] });
  }

  // Sort the machines by cost, ascending
  machines.sort((a, b) => a.cost - b.cost);

  // Create prefix array where prefixMax[i] stores max capacity among machines <= i
  const prefixMax = new Array(machines.length);
  let curMax = 0;

  for (let i = 0; i < machines.length; ++i) {
    curMax = Math.max(curMax, machines[i].capacity);
    prefixMax[i] = curMax;
  }

  let maxCapacity = 0;

  for (let i = 0; i < prefixMax.length; ++i) {
    // Can't afford this machine, and thus none after this (since sorted by cost)
    if (machines[i].cost >= budget) break;

    // Otherwise, we can afford this machine
    maxCapacity = Math.max(maxCapacity, machines[i].capacity);

    // We need to find the highest capacity second machine that is < our remaining budget
    // Due to the prefix nature, just find the right-most affordable machine
    const target = budget - machines[i].cost;
    let left = 0;
    let right = i - 1;
    let bestIdx = -1;

    while (left <= right) {
      const mid = left + Math.floor((right - left) / 2);
      if (machines[mid].cost < target) {
        bestIdx = mid;
        left = mid + 1;
      } else right = mid - 1;
    }

    if (bestIdx !== -1) maxCapacity = Math.max(maxCapacity, machines[i].capacity + prefixMax[bestIdx]);
  }

  return maxCapacity;
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N \* Log(N))  | O(N)             |
