# [199. Binary Tree Right Side View](https://leetcode.com/problems/binary-tree-right-side-view)

## Description

Given the `root` of a binary tree, imagine yourself standing on the **right side** of it, return the values of the nodes you can see ordered from top to bottom.

Example 1:

```
Input: root = [1,2,3,null,5,null,4]
Output: [1,3,4]
```

**Example 2:**

```
Input: root = [1,null,3]
Output: [1,3]
```

**Example 3:**

```
Input: root = []
Output: []
```

**Constraints:**

- The number of nodes in the tree is in the range [0, 100].
- -100 <= Node.val <= 100

## My Solution

**JavaScript**

```js
/*
Approach: Modified pre-order traversal, where we check right then left rather than left then right.
We can easily check if we are at the first node of each level with result.length < level.
Because we add the right node first, which will increase our result length by 1, it will then be
equal to the level size. When we visit nodes after the right node on the same level, result.length will
equal level length, and the conditional to push that node to the result will fail to be met.
*/
const rightSideView = (root) => {
  const result = [];

  const dfs = (root, level) => {
    if (!root) return;
    if (result.length < level) result.push(root.val);
    dfs(root.right, level + 1);
    dfs(root.left, level + 1);
  };

  dfs(root, 1);
  return result;
};
```

| Time Complexity | Space Complexity  |
| --------------- | ----------------- |
| O(N)            | O(Height of tree) |

**JavaScript**

```js
/*
Approach: We can observe that the right-most node on every level is the
only node that would be visible when viewed from the right. We can do a
level order traversal, pushing the last node in each level to a result array.
*/
const rightSideView = (root) => {
  if (!root) return [];

  const result = [];
  const queue = [root];

  while (queue.length) {
    const levelSize = queue.length;
    const rightMost = queue.at(levelSize - 1);
    result.push(rightMost.val);

    for (let i = 0; i < levelSize; ++i) {
      const current = queue.shift();
      if (current.left) queue.push(current.left);
      if (current.right) queue.push(current.right);
    }
  }

  return result;
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(N)             |

**Python**

```py
from collections import deque
def rightSideView(self, root: Optional[TreeNode]) -> List[int]:
    if not root:
        return []

    result = []
    queue = deque()
    queue.appendleft(root)

    while len(queue):
        level_length = len(queue)
        for i in range(level_length):
            current = queue.pop()

            if current.left: queue.appendleft(current.left)
            if current.right: queue.appendleft(current.right)

            if i == level_length - 1:
                result.append(current.val)

    return result
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(N)             |

**Java**

```java
public List<Integer> rightSideView(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null) return result;

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);

    while (!queue.isEmpty()) {
        int levelSize = queue.size();

        for (int i = 0; i < levelSize; ++i) {
            TreeNode current = queue.poll();

            // Add this node if it's the right-most of this level
            if (i == levelSize - 1) result.add(current.val);

            if (current.left != null) queue.offer(current.left);
            if (current.right != null) queue.offer(current.right);
        }
    }

    return result;
}
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(N)             |
