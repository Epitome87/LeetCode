# [797. All Paths From Source to Target](https://leetcode.com/problems/all-paths-from-source-to-target)

## Description

Given a directed acyclic graph (**DAG**) of `n` nodes labeled from `0` to `n - 1`, find all possible paths from node `0` to node `n - 1` and return them in **any order**.

The graph is given as follows: `graph[i]` is a list of all nodes you can visit from node `i` (i.e., there is a directed edge from node `i` to node `graph[i][j]`).

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/09/28/all_1.jpg)

**Input:** graph = \[\[1,2\],\[3\],\[3\],\[\]\]  
**Output:** \[\[0,1,3\],\[0,2,3\]\]  
**Explanation:** There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3.

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/09/28/all_2.jpg)

**Input:** graph = \[\[4,3,1\],\[3,2,4\],\[3\],\[4\],\[\]\]  
**Output:** \[\[0,4\],\[0,3,4\],\[0,1,3,4\],\[0,1,2,3,4\],\[0,1,4\]\]

**Constraints:**

- `n == graph.length`
- `2 <= n <= 15`
- `0 <= graph[i][j] < n`
- `graph[i][j] != i` (i.e., there will be no self-loops).
- All the elements of `graph[i]` are **unique**.
- The input graph is **guaranteed** to be a **DAG**.

## My Solution

**JavaScript**

```js
// Approach: Recursive
const allPathsSourceTarget = (graph) => {
  const result = [];

  const dfs = (node, path) => {
    path.push(node);

    if (node === graph.length - 1) {
      result.push([...path]);
    }

    for (const neighbor of graph[node]) {
      dfs(neighbor, path);
    }

    // Backtrack
    path.pop();
  };

  dfs(0, []);
  return result;
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N \* 2^N)     | O(N)             |

```js
// Approach: DFS graph traversal using iteration and stack
// Starting from node 0, traverse all possible paths, noting
// which of those can reach node n - 1
const allPathsSourceTarget = (graph) => {
  const result = [];
  const stack = [[0, [0]]]; // [node, path]

  while (stack.length) {
    const [node, path] = stack.pop();

    if (node === graph.length - 1) {
      result.push([...path]);
    }

    for (const neighbor of graph[node]) {
      stack.push([neighbor, [...path, neighbor]]);
    }
  }

  return result;
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N \* 2^N)     | O(N)             |
