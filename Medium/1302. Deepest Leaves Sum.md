# [1302. Deepest Leaves Sum](https://leetcode.com/problems/deepest-leaves-sum)

## Description

Given the `root` of a binary tree, return _the sum of values of its deepest leaves_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2019/07/31/1483_ex1.png)

**Input:** root = \[1,2,3,4,5,null,6,7,null,null,null,null,8\]  
**Output:** 15

**Example 2:**

**Input:** root = \[6,7,8,2,7,1,3,9,null,1,4,null,null,null,5\]  
**Output:** 19

**Constraints:**

- The number of nodes in the tree is in the range `[1, 104]`.
- `1 <= Node.val <= 100`

## My Solution

**JavaScript**

```js
// Approach: Using single pass by utilizing level-order traversal
const deepestLeavesSum = (root) => {
  let sum = 0;
  const queue = [root];

  while (queue.length) {
    // Reset sum each level. Since we do not know ahead of time which level
    // is the last, this will ensure sum stores the final level's sum in the end
    sum = 0;
    const levelSize = queue.length;

    for (let i = 0; i < levelSize; ++i) {
      const current = queue.shift();
      sum += current.val;

      if (current.left) queue.push(current.left);
      if (current.right) queue.push(current.right);
    }
  }

  return sum;
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(Width)         |

```js
// Approach: Using single pass and dfs recursion
const deepestLeavesSum = (root) => {
  let sum = 0;
  let maxLevel = 0;

  const dfs = (node, level) => {
    if (!node) return;

    if (level > maxLevel) {
      sum = 0;
      maxLevel = level;
    }

    if (level === maxLevel) {
      sum += node.val;
    }

    dfs(node.left, level + 1);
    dfs(node.right, level + 1);
  };

  dfs(root, 0);
  return sum;
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(Height)        |

**Java**

```java
class Solution {
    private int sum = 0;
    private int maxLevel = 0;

    public int deepestLeavesSum(TreeNode root) {
        if (root == null) return 0;
        sumAtLevel(root, 0);
        return sum;
    }

    private void sumAtLevel(TreeNode node, int level) {
        if (node == null) return;

        if (level > maxLevel) {
            sum = 0;
            maxLevel = level;
        }

        if (level == maxLevel) {
            sum += node.val;
        }

        sumAtLevel(node.left, level + 1);
        sumAtLevel(node.right, level + 1);
    }
}
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(Height)        |
