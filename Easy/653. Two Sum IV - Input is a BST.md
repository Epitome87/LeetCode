# [653. Two Sum IV - Input is a BST](https://leetcode.com/problems/two-sum-iv-input-is-a-bst)

## Description

Given the `root` of a binary search tree and an integer `k`, return `true` _if there exist two elements in the BST such that their sum is equal to_ `k`, _or_ `false` _otherwise_.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/09/21/sum_tree_1.jpg)

**Input:** root = [5,3,6,2,4,null,7], k = 9  
**Output:** true

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/09/21/sum_tree_2.jpg)

**Input:** root = [5,3,6,2,4,null,7], k = 28  
**Output:** false

**Constraints:**

- The number of nodes in the tree is in the range `[1, 10^4]`.
- `-10^4 <= Node.val <= 10^4`
- `root` is guaranteed to be a **valid** binary search tree.
- `-10^5 <= k <= 10^5`

## My Solution

**JavaScript**

```js
// Recursive DFS
const findTarget = (root, k) => {
  const nums = [];

  const inorder = (root) => {
    if (!root) return;
    inorder(root.left);
    nums.push(root.val);
    inorder(root.right);
  };

  // Begin recursive call to inorder to fill our nums array
  inorder(root);

  // Perform typical sorted two-sum with our two pointers
  for (let i = 0, j = nums.length - 1; i < j; ) {
    if (nums[i] + nums[j] === k) return true;
    if (nums[i] + nums[j] < k) i++;
    else j--;
  }

  return false;
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(N)             |

```js
// Depth-first search, iterative
// Take advantage of it being a BST by performing in-order traversal
const findTarget = (root, k) => {
  if (!root) return;

  // Keep track of what values we have seen
  const seen = new Set();

  // We need a stack to perform our dfs
  const stack = [];
  let current = root;

  while (current || stack.length) {
    // Reach the left-most node of this current node
    while (current) {
      stack.push(current);
      current = current.left;
    }

    // Current must be null at this point
    // So process the left-most node
    current = stack.pop();

    // What value do we need to reach k with this node?
    const target = k - current.val;

    // If current node's value is > k, and we are visiting values in ascending order...
    // there must not be a valid answer
    // if (current.val > k) return false;

    // If we've seen our target before, we have a valid solution
    if (seen.has(target)) return true;

    // Mark this value as seen
    seen.add(current.val);

    // We have visited the node and its left subtree
    // Now it's time for the right subtree
    current = current.right;
  }

  return false;
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(N)             |

```js
// Depth-first search, iterative
// Note we aren't really taking advantage of the fact this is a BST
const findTarget = (root, k) => {
  if (!root) return;

  // Keep track of what values we have seen
  const seen = new Set();

  // We need a stack to perform our dfs
  const stack = [root];

  while (stack.length) {
    // Process current node
    const node = stack.pop();

    // What is our target value, and have we seen this value previously?
    const need = k - node.val;
    if (seen.has(need)) return true;

    // We have now seen this node's value -- add it to set
    seen.add(node.val);

    // Push node's children for processing in stack
    if (node.left) stack.push(node.left);
    if (node.right) stack.push(node.right);
  }

  return false;
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(N)             |

**Python**

```python
def findTarget(self, root: Optional[TreeNode], k: int) -> bool:
    if not root: return

    seen = set()
    stack = []
    current = root

    while current or len(stack):
        while (current):
            stack.append(current)
            current = current.left

        current = stack.pop()
        target = k - current.val

        if target in seen: return True

        seen.add(current.val)
        current = current.right

    return False
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(N)             |
