# [1566. Detect Pattern of Length M Repeated K or More Times](https://leetcode.com/problems/detect-pattern-of-length-m-repeated-k-or-more-times)

## Description

Given an array of positive integers `arr`, find a pattern of length `m` that is repeated `k` or more times.

A **pattern** is a subarray (consecutive sub-sequence) that consists of one or more values, repeated multiple times **consecutively** without overlapping. A pattern is defined by its length and the number of repetitions.

Return `true` _if there exists a pattern of length_ `m` _that is repeated_ `k` _or more times, otherwise return_ `false`.

**Example 1:**

**Input:** arr = \[1,2,4,4,4,4\], m = 1, k = 3  
**Output:** true  
**Explanation:** The pattern **(4)** of length 1 is repeated 4 consecutive times. Notice that pattern can be repeated k or more times but not less.

**Example 2:**

**Input:** arr = \[1,2,1,2,1,1,1,3\], m = 2, k = 2  
**Output:** true  
**Explanation:** The pattern **(1,2)** of length 2 is repeated 2 consecutive times. Another valid pattern **(2,1) is** also repeated 2 times.

**Example 3:**

**Input:** arr = \[1,2,1,2,1,3\], m = 2, k = 3  
**Output:** false  
**Explanation:** The pattern (1,2) is of length 2 but is repeated only 2 times. There is no pattern of length 2 that is repeated 3 or more times.

**Constraints:**

- `2 <= arr.length <= 100`
- `1 <= arr[i] <= 100`
- `1 <= m <= 100`
- `2 <= k <= 100`

## My Solution

**JavaScript**

```js
// Approach: Sliding Window. A repeated pattern starting at i would also appear at i + m
const containsPattern = (arr, m, k) => {
  let count = 0;

  for (let i = 0; i < arr.length - m; ++i) {
    if (arr[i] === arr[i + m]) ++count;
    else count = 0;

    // For a pattern of length 3 that occurs twice, count would 3
    // For a pattern of length 4 that occurs thrice, count would be 8
    // We can generalize this as a count of m * (k - 1) being required to
    // satisfy a pattern of length m being repeated >= k times.
    if (count === m * (k - 1)) return true;
  }

  return false;
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(1)             |

```js
// Approach: Brute-Force
const containsPattern = (arr, m, k) => {
  // Try every possible starting index
  for (let start = 0; start <= arr.length - m * k; start++) {
    let patternFound = true;

    // Check each of the k repetitions
    for (let rep = 1; rep < k; rep++) {
      // Compare this block with the first pattern
      for (let j = 0; j < m; j++) {
        if (arr[start + rep * m + j] !== arr[start + j]) {
          patternFound = false;
          break;
        }
      }
      if (!patternFound) break;
    }

    if (patternFound) return true;
  }

  return false;
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N x M x K)    | O(1)             |

**Python**

```python
def containsPattern(self, arr, m, k):
    count = 0

    for i in range(0, len(arr) - m):
        if arr[i] == arr[i + m]:
            count += 1
        else:
            count = 0
        if count == m * (k - 1):
            return True

    return False
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(1)             |

**Java**

```java
public boolean containsPattern(int[] arr, int m, int k) {
    int count = 0;

    for (int i = 0; i < arr.length - m; ++i) {
        if (arr[i] == arr[i + m]) ++count;
        else count = 0;
        if (count == m * (k - 1)) return true;
    }

    return false;
}
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(1)             |
