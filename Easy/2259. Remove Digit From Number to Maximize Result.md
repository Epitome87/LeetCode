# [2259. Remove Digit From Number to Maximize Result](https://leetcode.com/problems/remove-digit-from-number-to-maximize-result)

## Description

You are given a string `number` representing a **positive integer** and a character `digit`.

Return _the resulting string after removing **exactly one occurrence** of_ `digit` _from_ `number` _such that the value of the resulting string in **decimal** form is **maximized**_. The test cases are generated such that `digit` occurs at least once in `number`.

**Example 1:**

**Input:** number = "123", digit = "3"  
**Output:** "12"  
**Explanation:** There is only one '3' in "123". After removing '3', the result is "12".

**Example 2:**

**Input:** number = "1231", digit = "1"  
**Output:** "231"  
**Explanation:** We can remove the first '1' to get "231" or remove the second '1' to get "123".  
Since 231 > 123, we return "231".

**Example 3:**

**Input:** number = "551", digit = "5"  
**Output:** "51"  
**Explanation:** We can remove either the first or second '5' from "551".  
Both result in the string "51".

**Constraints:**

- `2 <= number.length <= 100`
- `number` consists of digits from `'1'` to `'9'`.
- `digit` is a digit from `'1'` to `'9'`.
- `digit` occurs at least once in `number`.

## My Solution

**JavaScript**

```js
// Approach: Scan left-to-right for digit. Whenever it is found, if the digit
// to its right is greater than it, removing this occurrence of digit yields highest
// value. If no such neighbor is found, simply remove the last occurrence of digit.
const removeDigit = (number, digit) => {
  for (let i = 0; i < number.length - 1; ++i) {
    if (number[i] === digit && number[i + 1] > digit) {
      return number.slice(0, i) + number.slice(i + 1);
    }
  }

  const lastIdxOfDigit = number.lastIndexOf(digit);
  return number.slice(0, lastIdxOfDigit) + number.slice(lastIdxOfDigit + 1);
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(N)             |

```js
// Approach: Brute-Force
const removeDigit = (number, digit) => {
  let result = '';

  for (let i = 0; i < number.length; ++i) {
    if (number[i] === digit) {
      value = number.slice(0, i) + number.slice(i + 1);
      if (value > result) result = value;
    }
  }

  return result;
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N^2)          | O(N)             |

**Python**

```python
def removeDigit(self, number: str, digit: str) -> str:
    for i in range(len(number) - 1):
        if number[i] == digit and number[i + 1] > number[i]:
            return number[0:i] + number[i + 1:]

    last_idx = number.rfind(digit)
    return number[0:last_idx] + number[last_idx + 1:]
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(N)             |

**Java**

```java
public String removeDigit(String number, char digit) {
    int idx = 0;

    for (int i = 0; i < number.length(); ++i) {
        if (number.charAt(i) == digit) {
            idx = i;
            if (i < number.length() - 1 && number.charAt(i + 1) > digit) {
                break;
            }
        }
    }

    return number.substring(0, idx) + number.substring(idx + 1);
}
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(N)             |
