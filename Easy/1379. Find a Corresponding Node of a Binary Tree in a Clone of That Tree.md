# [1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree](https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree)

## Description

Given two binary trees `original` and `cloned` and given a reference to a node `target` in the original tree.

The `cloned` tree is a **copy of** the `original` tree.

Return _a reference to the same node_ in the `cloned` tree.

**Note** that you are **not allowed** to change any of the two trees or the `target` node and the answer **must be** a reference to a node in the `cloned` tree.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/02/21/e1.png)

**Input:** tree = \[7,4,3,null,null,6,19\], target = 3  
**Output:** 3  
**Explanation:** In all examples the original and cloned trees are shown. The target node is a green node from the original tree. The answer is the yellow node from the cloned tree.

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/02/21/e2.png)

**Input:** tree = \[7\], target = 7  
**Output:** 7

**Example 3:**

![](https://assets.leetcode.com/uploads/2020/02/21/e3.png)

**Input:** tree = \[8,null,6,null,5,null,4,null,3,null,2,null,1\], target = 4  
**Output:** 4

**Constraints:**

- The number of nodes in the `tree` is in the range `[1, 104]`.
- The values of the nodes of the `tree` are unique.
- `target` node is a node from the `original` tree and is not `null`.

**Follow up:** Could you solve the problem if repeated values on the tree are allowed?

## My Solution

**JavaScript**

```js
// Approach: Given the problem description, we do not even need to check for a node's
// value. Rather, we can use the reference equality check in languages such as JavaScript & Python.
// We recursively check each tree by pairing a node from the original tree with its equivalent in the cloned tree.
const getTargetCopy = (original, cloned, target) => {
  if (!original) return null;

  // Did we find the target?
  if (original === target) return cloned;

  // Target must be in left or right subtrees. Change the original / cloned arguments accordingly.
  return getTargetCopy(original.left, cloned.left, target) || getTargetCopy(original.right, cloned.right, target);
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(Height)        |

```js
// Approach: Using BFS, simply check if the current node's value is the same
// as the target node's value. This is sufficient since the problem specifies
// the tree only has unique values. This would not work otherwise!
const getTargetCopy = (original, cloned, target) => {
  const queue = [cloned];

  while (queue.length) {
    const current = queue.shift();
    if (current.val === target.val) return current;
    if (current.left) queue.push(current.left);
    if (current.right) queue.push(current.right);
  }
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(Width)         |

**Python**

```python
def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:
    if not original: return None
    if original is target: return cloned
    return self.getTargetCopy(original.left, cloned.left, target) or self.getTargetCopy(original.right, cloned.right, target)
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(Height)        |
