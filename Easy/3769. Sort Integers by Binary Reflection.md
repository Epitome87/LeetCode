# [3769. Sort Integers by Binary Reflection](https://leetcode.com/problems/sort-integers-by-binary-reflection)

## Description

You are given an integer array `nums`.

The **binary reflection** of a **positive** integer is defined as the number obtained by reversing the order of its **binary** digits (ignoring any leading zeros) and interpreting the resulting binary number as a decimal.

Sort the array in **ascending** order based on the binary reflection of each element. If two different numbers have the same binary reflection, the **smaller** original number should appear first.

Return the resulting sorted array.

**Example 1:**

**Input:** nums = \[4,5,4\]  
**Output:** \[4,4,5\]  
**Explanation:**  
Binary reflections are:

- 4 -> (binary) `100` -> (reversed) `001` -> 1
- 5 -> (binary) `101` -> (reversed) `101` -> 5
- 4 -> (binary) `100` -> (reversed) `001` -> 1

Sorting by the reflected values gives `[4, 4, 5]`.

**Example 2:**

**Input:** nums = \[3,6,5,8\]  
**Output:** \[8,3,6,5\]  
**Explanation:**  
Binary reflections are:

- 3 -> (binary) `11` -> (reversed) `11` -> 3
- 6 -> (binary) `110` -> (reversed) `011` -> 3
- 5 -> (binary) `101` -> (reversed) `101` -> 5
- 8 -> (binary) `1000` -> (reversed) `0001` -> 1

Sorting by the reflected values gives `[8, 3, 6, 5]`.  
Note that 3 and 6 have the same reflection, so we arrange them in increasing order of original value.

**Constraints:**

- `1 <= nums.length <= 100`
- `1 <= nums[i] <= 10^9`

## My Solution

**JavaScript**

```js
const sortByReflection = (nums) => {
  const binaryReflection = (num) => {
    let reversed = 0;

    while (num) {
      // num & 1: extracts least significant bit
      // reversed << 1 makes room for new bit
      // | adds the least significant bit to reversed
      // Could also do reversed = (reversed << 1) + (num % 2)
      reversed = (reversed << 1) | (num & 1);
      num >>>= 1;
    }

    return reversed >>> 0;
  };

  return nums.toSorted((a, b) => {
    const reflectionA = binaryReflection(a);
    const reflectionB = binaryReflection(b);
    return reflectionA - reflectionB || a - b;
  });
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N \* Log(N))  | O(N), O(1) aux   |

```js
// Approach: Using strings
const sortByReflection = (nums) => {
  return nums.toSorted((a, b) => {
    const reflectionA = +[...parseInt(a).toString(2)].reverse().join('');
    const reflectionB = +[...parseInt(b).toString(2)].reverse().join('');
    return reflectionA - reflectionB || a - b;
  });
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N \* Log(N))  | O(N), O(1) aux   |

**Python**

```python
def sortByReflection(self, nums):
    def binaryReflection(num):
        reversed = 0
        while num:
            reversed = (reversed << 1) | (num & 1)
            num >>= 1
        return reversed

    return sorted(nums, key=lambda num : (binaryReflection(num), num))
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N \* Log(N))  | O(N), O(1) aux   |
