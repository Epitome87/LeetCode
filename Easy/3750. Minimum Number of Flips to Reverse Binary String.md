# [3750. Minimum Number of Flips to Reverse Binary String](https://leetcode.com/problems/minimum-number-of-flips-to-reverse-binary-string)

## Description

You are given a **positive** integer `n`.

Let `s` be the **binary representation** of `n` without leading zeros.

The **reverse** of a binary string `s` is obtained by writing the characters of `s` in the opposite order.

You may flip any bit in `s` (change `0 → 1` or `1 → 0`). Each flip affects **exactly** one bit.

Return the **minimum** number of flips required to make `s` equal to the reverse of its original form.

**Example 1:**

**Input:** n = 7  
**Output:** 0  
**Explanation:**  
The binary representation of 7 is `"111"`. Its reverse is also `"111"`, which is the same. Hence, no flips are needed.

**Example 2:**

**Input:** n = 10  
**Output:** 4  
**Explanation:**  
The binary representation of 10 is `"1010"`. Its reverse is `"0101"`. All four bits must be flipped to make them equal. Thus, the minimum number of flips required is 4.

**Constraints:**

- `1 <= n <= 10^9`

## My Solution

**JavaScript**

```js
const minimumFlips = (n) => {
  let result = 0;
  let temp = n;
  let left = 0;
  let right = -1;

  // Calculate the index of the right-most bit
  while (temp > 0) {
    temp >>= 1;
    ++right;
  }

  while (left < right) {
    const lowBit = (n >> left) & 1;
    const highBit = (n >> right) & 1;
    result += lowBit ^ highBit;
    ++left;
    --right;
  }

  return 2 * result;
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(Log(N))       | O(1)             |

```js
// Approach: Using strings
const minimumFlips = (n) => {
  let result = 0;
  const numStr = n.toString(2);

  for (let i = 0; i < numStr.length; ++i) {
    if (numStr[i] !== numStr[numStr.length - i - 1]) {
      ++result;
    }
  }

  return result;
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(Log(N))       | O(Log(N))        |

**Python**

```python
def minimumFlips(self, n: int) -> int:
    num_flips = 0
    left = 0
    right = -1
    temp = n

    while temp:
        temp = temp >> 1
        right += 1

    while left < right:
        low_bit = (n >> left) & 1
        high_bit = (n >> right) & 1
        num_flips += low_bit ^ high_bit
        left += 1
        right -= 1

    return num_flips * 2
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(Log(N))       | O(Log(N))        |

**Java**

```java
public int minimumFlips(int n) {
    int numFlips = 0;
    int left = 0;
    int right = -1;
    int temp = n;

    while (temp > 0) {
        temp = temp >> 1;
        ++right;
    }

    while (left < right) {
        final int lowBit = (n >> left) & 1;
        final int highBit = (n >> right) & 1;
        numFlips += lowBit ^ highBit;
        ++left;
        --right;
    }

    return numFlips * 2;
}
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(Log(N))       | O(Log(N))        |
