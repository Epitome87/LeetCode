# [3750. Minimum Number of Flips to Reverse Binary String](https://leetcode.com/problems/minimum-number-of-flips-to-reverse-binary-string)

## Description

You are given a **positive** integer `n`.

Let `s` be the **binary representation** of `n` without leading zeros.

The **reverse** of a binary string `s` is obtained by writing the characters of `s` in the opposite order.

You may flip any bit in `s` (change `0 → 1` or `1 → 0`). Each flip affects **exactly** one bit.

Return the **minimum** number of flips required to make `s` equal to the reverse of its original form.

**Example 1:**

**Input:** n = 7  
**Output:** 0  
**Explanation:**  
The binary representation of 7 is `"111"`. Its reverse is also `"111"`, which is the same. Hence, no flips are needed.

**Example 2:**

**Input:** n = 10  
**Output:** 4  
**Explanation:**  
The binary representation of 10 is `"1010"`. Its reverse is `"0101"`. All four bits must be flipped to make them equal. Thus, the minimum number of flips required is 4.

**Constraints:**

- `1 <= n <= 10^9`

## My Solution

**JavaScript**

```js
const minimumFlips = (n) => {
  let result = 0;
  let temp = n;
  let left = 0;
  let right = -1;

  // Calculate the index of the right-most bit
  while (temp > 0) {
    temp >>= 1;
    ++right;
  }

  while (left < right) {
    const leftBit = (n >> left) & 1;
    const rightBit = (n >> right) & 1;
    result += leftBit ^ rightBit;
    ++left;
    --right;
  }

  return 2 * result;
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(Log(N))       | O(1)             |

```js
// Approach: Using strings
const minimumFlips = (n) => {
  let result = 0;
  const numStr = n.toString(2);

  for (let i = 0; i < numStr.length; ++i) {
    if (numStr[i] !== numStr[numStr.length - i - 1]) {
      ++result;
    }
  }

  return result;
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(Log(N))       | O(Log(N))        |
