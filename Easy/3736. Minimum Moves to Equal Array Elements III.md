# [3736. Minimum Moves to Equal Array Elements III](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-iii)

## Description

You are given an integer array `nums`.

In one move, you may **increase** the value of any single element `nums[i]` by 1.

Return the **minimum total** number of **moves** required so that all elements in `nums` become **equal**.

**Example 1:**

**Input:** nums = \[2,1,3\]  
**Output:** 3  
**Explanation:**  
To make all elements equal:

- Increase `nums[0] = 2` by 1 to make it 3.
- Increase `nums[1] = 1` by 1 to make it 2.
- Increase `nums[1] = 2` by 1 to make it 3.

Now, all elements of `nums` are equal to 3. The minimum total moves is `3`.

**Example 2:**

**Input:** nums = \[4,4,5\]  
**Output:** 2  
**Explanation:**  
To make all elements equal:

- Increase `nums[0] = 4` by 1 to make it 5.
- Increase `nums[1] = 4` by 1 to make it 5.

Now, all elements of `nums` are equal to 5. The minimum total moves is `2`.

**Constraints:**

- `1 <= nums.length <= 100`
- `1 <= nums[i] <= 100`

## My Solution

**JavaScript**

```js
const minMoves = (nums) => {
  let maxNum = 1;
  let sum = 0;

  for (let num of nums) {
    maxNum = Math.max(maxNum, num);
    sum += num;
  }

  const targetSum = maxNum * nums.length;
  const neededSum = targetSum - sum;

  return neededSum;
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(1)             |

**Python**

```python
def minMoves(self, nums: List[int]) -> int:
    max_num = 1
    sum = 0

    for num in nums:
        max_num = max(max_num, num)
        sum += num

    return max_num * len(nums) - sum
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(1)             |
