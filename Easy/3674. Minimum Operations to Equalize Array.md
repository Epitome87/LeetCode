# [3674. Minimum Operations to Equalize Array](https://leetcode.com/problems/minimum-operations-to-equalize-array)

## Description

You are given an integer array `nums` of length `n`.

In one operation, choose any subarray `nums[l...r]` (`0 <= l <= r < n`) and **replace** each element in that subarray with the **bitwise AND** of all elements.

Return the **minimum** number of operations required to make all elements of `nums` equal.

A **subarray** is a contiguous **non-empty** sequence of elements within an array.

**Example 1:**

**Input:** nums = \[1,2\]  
**Output:** 1  
**Explanation:** Choose `nums[0...1]`: `(1 AND 2) = 0`, so the array becomes `[0, 0]` and all elements are equal in 1 operation.

**Example 2:**

**Input:** nums = \[5,5,5\]  
**Output:** 0  
**Explanation:** `nums` is `[5, 5, 5]` which already has all elements equal, so 0 operations are required.

**Constraints:**

- `1 <= n == nums.length <= 100`
- `1 <= nums[i] <= 10^5`

## My Solution

**JavaScript**

```js
// Approach: If all the numbers are initially the same, we require 0 replacements.
// Otherwise, we only ever need at most 1 replacement, as we can simply choose the entire
// range of the array to perform the bitwise AND on, and replace that range with the result.
const minOperations = (nums) => +nums.some((num) => num !== nums[0]);
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(1)             |

**Python**

```python
def minOperations(self, nums: List[int]) -> int:
    return int(any(num != nums[0] for num in nums))
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(1)             |
