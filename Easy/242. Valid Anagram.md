# [242. Valid Anagram](https://leetcode.com/problems/valid-anagram)

## Description

Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.

An **Anagram** is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.

**Example 1:**

Input: s = "anagram", t = "nagaram"  
Output: true

**Example 2:**

Input: s = "rat", t = "car"  
Output: false

**Constraints:**

- 1 <= s.length, t.length <= 5 \* 10<sup>4</sup>
- `s` and `t` consist of lowercase English letters.

**Follow up:** What if the inputs contain Unicode characters? How would you adapt your solution to such a case?

## My Solution

**JavaScript**

```js
// Approach: Early return if lengths aren't equal and if t has a greater
// frequency of a character than s. These conditions are sufficient enough to
// avoid the usual final for-loop that checks if all counts are 0
const isAnagram = (s, t) => {
  if (s.length != t.length) return false;

  const count = new Array(26).fill(0);

  for (const char of s) count[char.charCodeAt() - 97]++;
  for (const char of t) {
    count[char.charCodeAt() - 97]--;
    if (count[char.charCodeAt() - 97] < 0) {
      return false;
    }
  }

  return true;
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(1)             |

```js
const isAnagram = (s, t) => {
  if (s.length !== t.length) return false;

  const mapA = new Map();
  const mapB = new Map();

  for (const char of s) {
    mapA.set(char, mapA.get(char) + 1 || 1);
  }

  for (const char of t) {
    mapB.set(char, mapB.get(char) + 1 || 1);
  }

  for (const [key, val] of mapA) {
    if (val !== mapB.get(key)) return false;
  }

  return true;
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(N)             |

```js
const isAnagram = (s, t) => [...s].sort().join('') === [...t].sort().join('');
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N \* Log(N))  | O(N)             |

**Python**

```python
def isAnagram(self, s: str, t: str) -> bool:
    if len(s) != len(t):
        return  False

    counts = [0] * 26

    for char in s:
        counts[ord(char) - ord('a')] += 1

    for char in t:
        counts[ord(char) - ord('a')] -= 1
        if counts[ord(char) - ord('a')] < 0:
            return False

    return True
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(1)             |

```python
from collections import Counter

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        return Counter(s) == Counter(t)
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(1)             |

```python
class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t): return False
        map = {}
        for i in range(len(s)):
            map[s[i]] = map.get(s[i], 0) + 1
            map[t[i]] = map.get(t[i], 0) - 1
        return all(map[x] == 0 for x in map)
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(N)             |

**Java**

```java
public boolean isAnagram(String s, String t) {
    if (s.length() != t.length()) {
        return false;
    }

    int[] counts = new int[26];

    for (char c : s.toCharArray()) {
        ++counts[c - 'a'];
    }

    for (char c : t.toCharArray()) {
        if (--counts[c - 'a'] < 0) {
            return false;
        }
    }

    return true;
}
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(1)             |
