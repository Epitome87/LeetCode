# [706. Design HashMap](https://leetcode.com/problems/design-hashmap)

## Description

Design a HashMap without using any built-in hash table libraries.

Implement the `MyHashMap` class:

- `MyHashMap()` initializes the object with an empty map.
- `void put(int key, int value)` inserts a `(key, value)` pair into the HashMap. If the `key` already exists in the map, update the corresponding `value`.
- `int get(int key)` returns the `value` to which the specified `key` is mapped, or `-1` if this map contains no mapping for the `key`.
- `void remove(key)` removes the `key` and its corresponding `value` if the map contains the mapping for the `key`.

**Example 1:**

**Input**
\["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"\]  
\[\[\], \[1, 1\], \[2, 2\], \[1\], \[3\], \[2, 1\], \[2\], \[2\], \[2\]\]  
**Output**
\[null, null, null, 1, -1, null, 1, null, -1\]

**Explanation**  
MyHashMap myHashMap = new MyHashMap();  
myHashMap.put(1, 1); // The map is now \[\[1,1\]\]  
myHashMap.put(2, 2); // The map is now \[\[1,1\], \[2,2\]\]  
myHashMap.get(1); // return 1, The map is now \[\[1,1\], \[2,2\]\]  
myHashMap.get(3); // return -1 (i.e., not found), The map is now \[\[1,1\], \[2,2\]\]  
myHashMap.put(2, 1); // The map is now \[\[1,1\], \[2,1\]\] (i.e., update the existing value)  
myHashMap.get(2); // return 1, The map is now \[\[1,1\], \[2,1\]\]  
myHashMap.remove(2); // remove the mapping for 2, The map is now \[\[1,1\]\]  
myHashMap.get(2); // return -1 (i.e., not found), The map is now \[\[1,1\]\]

**Constraints:**

- `0 <= key, value <= 10^6`
- At most `10^4` calls will be made to `put`, `get`, and `remove`.

## My Solution

**JavaScript**

```js
class MyHashMap {
  constructor() {
    this.capacity = 997; // Prime capacities are ideal
    this.count = 0;
    this.data = new Array(this.capacity).fill(null).map(() => []);
    this.loadFactorMaxThreshold = 0.6; // If 60% of capacity is used, grow it
    this.loadFactorMinThreshold = 0.2; // If 20% of capacity is used, shrink it
    this.minCapacity = 31; // Ensure we have room for at least 31 items (again, prime)
  }

  put(key, value) {
    const index = this._hash(key);
    let bucket = this.data[index];

    for (let i = 0; i < bucket.length; ++i) {
      const [k, _] = bucket[i];
      if (k === key) {
        bucket[i][1] = value;
        return;
      }
    }

    // This key is new to hash map, add it and its value
    bucket.push([key, value]);
    ++this.count;

    // Do we need to up the capacity after this insertion?
    if (this.count > this.capacity * this.loadFactorThreshold) {
      this._resize(this.capacity * 2);
    }
  }

  get(key) {
    const index = this._hash(key);
    const bucket = this.data[index];

    for (const [k, v] of bucket) {
      if (k === key) return v;
    }

    return -1;
  }

  remove(key) {
    const index = this._hash(key);
    const bucket = this.data[index];

    for (let i = 0; i < bucket.length; ++i) {
      const [k, v] = bucket[i];
      if (k === key) {
        bucket.splice(i, 1);
        --this.count;

        if (this.count < this.capacity * this.loadFactorMinThreshold && this.capacity > this.minCapacity) {
          this._resize(Math.max(this.minCapacity, Math.floor(this.capacity / 2)));
        }

        return;
      }
    }
  }

  _resize(newCapacity) {
    const oldData = this.data;
    this.capacity = newCapacity;
    this.data = new Array(this.capacity).fill(null).map(() => []);

    for (const bucket of oldData) {
      for (const [key, value] of bucket) {
        const newIndex = this._hash(key);
        this.data[newIndex].push([key, value]);
      }
    }
  }

  _hash(key) {
    return (key * 31) % this.capacity;
  }
}
```