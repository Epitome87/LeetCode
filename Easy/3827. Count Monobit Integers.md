# [3827. Count Monobit Integers](https://leetcode.com/problems/count-monobit-integers)

## Description

You are given an integer `n`.

An integer is called **Monobit** if all bits in its binary representation are the same.

Return the count of **Monobit** integers in the range `[0, n]` (inclusive).

**Example 1:**

**Input:** n = 1  
**Output:** 2  
**Explanation:**

- The integers in the range `[0, 1]` have binary representations `"0"` and `"1"`.
- Each representation consists of identical bits. Thus, the answer is 2.

**Example 2:**

**Input:** n = 4  
**Output:** 3  
**Explanation:**

- The integers in the range `[0, 4]` include binaries `"0"`, `"1"`, `"10"`, `"11"`, and `"100"`.
- Only 0, 1 and 3 satisfy the Monobit condition. Thus, the answer is 3.

**Constraints:**

- `0 <= n <= 1000`

## My Solution

**JavaScript**

```js
// Approach: Note that monobits are either all 0 (just the value 0 in decimal)
// or all 1's (like 1, 3, 7, i.e 2^k - 1).
const countMonobit = (n) => {
  if (n < 0) return 0;

  let result = 1; // 0 is monobit, so include it
  let current = 1; // 2^1 - 1 is our next monobit after 0

  while (current <= n) {
    ++result;
    // The next monobiis found by appending a 1 to the current binary
    // I.e 1 becomes 11. This is done by left-shifting once and adding 1
    current = (current << 1) + 1;
  }

  return result;
};
```

```js
// Approach: Brute-Force
const countMonobit = (n) => {
  let result = 0;

  for (let i = 0; i <= n; ++i) {
    if (isMonobit(i)) ++result;
  }

  return result;
};

const isMonobit = (n) => {
  let lastDigit = n % 2;

  while (n) {
    const digit = n % 2;
    n = Math.floor(n / 2);
    if (digit !== lastDigit) return false;
  }

  return true;
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(Log(N))       | O(1)             |
