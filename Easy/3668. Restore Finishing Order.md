# [3668. Restore Finishing Order](https://leetcode.com/problems/restore-finishing-order)

## Description

You are given an integer array `order` of length `n` and an integer array `friends`.

- `order` contains every integer from 1 to `n` **exactly once**, representing the IDs of the participants of a race in their **finishing** order.
- `friends` contains the IDs of your friends in the race **sorted** in strictly increasing order. Each ID in friends is guaranteed to appear in the `order` array.

Return an array containing your friends' IDs in their **finishing** order.

**Example 1:**

**Input:** order = \[3,1,2,5,4\], friends = \[1,3,4\]  
**Output:** \[3,1,4\]  
**Explanation:**  
The finishing order is `[**3**, **1**, 2, 5, **4**]`. Therefore, the finishing order of your friends is `[3, 1, 4]`.

**Example 2:**

**Input:** order = \[1,4,5,3,2\], friends = \[2,5\]  
**Output:** \[5,2\]  
**Explanation:**  
The finishing order is `[1, 4, **5**, 3, **2**]`. Therefore, the finishing order of your friends is `[5, 2]`.

**Constraints:**

- `1 <= n == order.length <= 100`
- `order` contains every integer from 1 to `n` exactly once
- `1 <= friends.length <= min(8, n)`
- `1 <= friends[i] <= n`
- `friends` is strictly increasing

## My Solution

**JavaScript**

```js
const recoverOrder = (order, friends) => {
  const result = [];
  const friendSet = new Set(friends);

  for (let o of order) {
    if (friendSet.has(o)) {
      result.push(o);
    }
  }

  return result;
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(N)             |

**Python**

```python
def recoverOrder(self, order: List[int], friends: List[int]) -> List[int]:
    friend_set = set(friends)
    return [o for o in order if o in friend_set]
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(N)             |

**Java**

```java
public int[] recoverOrder(int[] order, int[] friends) {
    HashSet<Integer> friendSet = new HashSet<>();
    int[] result = new int[friends.length];
    int idx = 0;

    for (int i = 0; i < friends.length; ++i) {
        friendSet.add(friends[i]);
    }

    for (int i = 0; i < order.length; ++i) {
        if (friendSet.contains(order[i])) {
            result[idx++] = order[i];
        }
    }

    return result;
}
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(N)             |
