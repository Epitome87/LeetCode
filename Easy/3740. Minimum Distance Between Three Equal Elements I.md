# [3740. Minimum Distance Between Three Equal Elements I](https://leetcode.com/problems/minimum-distance-between-three-equal-elements-i)

## Description

You are given an integer array `nums`.

A tuple `(i, j, k)` of 3 **distinct** indices is **good** if `nums[i] == nums[j] == nums[k]`.

The **distance** of a **good** tuple is `abs(i - j) + abs(j - k) + abs(k - i)`, where `abs(x)` denotes the **absolute value** of `x`.

Return an integer denoting the **minimum** possible **distance** of a **good** tuple. If no **good** tuples exist, return `-1`.

**Example 1:**

**Input:** nums = \[1,2,1,1,3\]  
**Output:** 6  
**Explanation:**  
The minimum distance is achieved by the good tuple `(0, 2, 3)`.  
`(0, 2, 3)` is a good tuple because `nums[0] == nums[2] == nums[3] == 1`. Its distance is `abs(0 - 2) + abs(2 - 3) + abs(3 - 0) = 2 + 1 + 3 = 6`.

**Example 2:**

**Input:** nums = \[1,1,2,3,2,1,2\]  
**Output:** 8  
**Explanation:**  
The minimum distance is achieved by the good tuple `(2, 4, 6)`.  
`(2, 4, 6)` is a good tuple because `nums[2] == nums[4] == nums[6] == 2`. Its distance is `abs(2 - 4) + abs(4 - 6) + abs(6 - 2) = 2 + 2 + 4 = 8`.

**Example 3:**

**Input:** nums = \[1\]  
**Output:** \-1  
**Explanation:**  
There are no good tuples. Therefore, the answer is -1.

**Constraints:**

- `1 <= n == nums.length <= 100`
- `1 <= nums[i] <= n`

## My Solution

**JavaScript**

```js
/*
Approach: Using hash maps.
Rather than abs(i - j) + abs(j - k) + abs(k - i), we can make a simplification:
Since we know i < j < k, there is no need for absolute values. 
So we have j - i + k - j + k - i, or 2k - 2i, or 2(k - i).
This leaves us to a critical observation: the actual middle index does not matter,
so long as it exists. 
*/
const minimumDistance = (nums) => {
  let minDistance = Infinity;
  const lastSeen = {};
  const secondLastSeen = {};

  for (let i = 0; i < nums.length; ++i) {
    const value = nums[i];

    // Have we found the third occurrence of a number?
    if (secondLastSeen[value] !== undefined) {
      const firstIndex = secondLastSeen[value];

      // Remember, distance formula simplified to 2(i - k)
      const curDistance = 2 * (i - firstIndex);
      minDistance = Math.min(minDistance, curDistance);

      // Update the two maps
      secondLastSeen[value] = lastSeen[value];
      lastSeen[value] = i;
    } else if (lastSeen[value] !== undefined) {
      // Second occurrence found?
      secondLastSeen[value] = lastSeen[value];
      lastSeen[value] = i;
    } else lastSeen[value] = i; // First occurrence
  }

  return minDistance === Infinity ? -1 : minDistance;
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(N)             |

```js
// Approach: Brute-Force
const minimumDistance = (nums) => {
  let minDistance = Infinity;

  for (let i = 0; i < nums.length - 2; ++i) {
    const value = nums[i];

    for (let j = i + 1; j < nums.length - 1; ++j) {
      if (nums[j] !== value) continue;

      const distanceA = Math.abs(i - j);

      for (let k = j + 1; k < nums.length; ++k) {
        if (nums[k] !== value) continue;

        const distanceB = Math.abs(j - k);
        const distanceC = Math.abs(k - i);

        minDistance = Math.min(minDistance, distanceA + distanceB + distanceC);
      }
    }
  }

  return minDistance === Infinity ? -1 : minDistance;
};
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N^3)          | O(1)             |

**Python**

```python
def minimumDistance(self, nums: List[int]) -> int:
    last_seen = {}
    second_last_seen = {}
    min_distance = float('inf')

    for i, num in enumerate(nums):
        if num in second_last_seen:                     # Third time seeing this number?
            first_idx = second_last_seen[num]
            cur_dist = 2 * (i - first_idx)

            # Update potential result
            min_distance = min(min_distance, cur_dist)

            # Update maps
            second_last_seen[num] = last_seen[num]
            last_seen[num] = i
        elif num in last_seen:                          # Second time seeing this number?
            second_last_seen[num] = last_seen[num]
            last_seen[num] = i
        else: last_seen[num] = i                        # First time seeing this number?

    return min_distance if min_distance != float('inf') else -1
```

| Time Complexity | Space Complexity |
| --------------- | ---------------- |
| O(N)            | O(N)             |
